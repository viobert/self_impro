# KMP

## 简介

**利用双指针操作的一个典型代表！**

在字符串中查找子串：Knuth-Morris-Pratt 算法

该算法由 Knuth、Pratt 和 Morris 在 1977 年共同发布[[1]](https://epubs.siam.org/doi/abs/10.1137/0206024)。

该任务是前缀函数的一个典型应用。

## Method

给定一个文本`t`和一个字符串`s`，我们尝试找到并展示`s`在`t`中的所有出现（occurrence)。

为了简便起见，我们用`m`表示字符串 `s`的长度，用`n`表示文本`t`的长度。

### 首先暴力

```c++
for (int i = 1; i <= n; i++)
{
		for (int j = 1; j <= m; j++)
		{
				if (s[j] != t[i])
        {
          false;
          break;
        }
		}
	}
}
```

可以看到，暴力时，当子串匹配到一半时会因为下一个字符不匹配而重新开始。这十分令人难过，毕竟好不容易匹配了这么久了。

### 而优化就是想着：

这么久的匹配过程中，虽然我没能成功，但是有没有可以利用的经验呢？

当然是有的。KMP就是通过预先处理子串：如果子串中有重复出现的**前缀部分**，那太好了。我们会尝试着直接把那一大段移动过来，接着去尝试。

前缀部分：自字符串开头到`j`的一个区间长度。KMP关于子串的预处理，就是记录了一个：

```c++
nxt[i] = x;
// 表示 [1, x]  [i - x + 1, j] 这两个区间的字符串相等
```

那么也就意味着，将来有一天子串在`j`这个地方失败了，我就直接将子串头移动到`nxt[j - 1]`的地方继续匹配；还是不行？那就是`nxt[nxt[j - 1]]`了；反复下去。

### 跳过这么多，中间不会有匹配的吗？

+ 暴力的情况下，我总是将子串头移动1位，然后不断重复。
    + 优化的情况下，我还是移动头，只不过我确定他要移动到什么位置。
+ 而且，我一定会移动到最符合（最长，`nxt[]`最大）的地方，如果中间还有一个地方能让我把子串头移动过去，那就是`nxt[i] = x;`统计错了。

动手画个图的话会更好理解。

于是，Knuth-Morris-Pratt 算法（简称 KMP 算法）用$O(n+m)$的时间以及$O(n)$的内存解决了该问题。

### 怎么求nxt数组

其实子串求nxt的过程和匹配过程基本类似。简称自己与自己做匹配。

## Code

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 1e6 + 10;
const int M = 1e5 + 10;

int n, m;
char s[N], p[M];
int nxt[M];

int main()
{
    cin >> n >> (p + 1) >> m >> (s + 1);

    // 预生成nxt
    for (int i = 2, j = 0; i <= n; i++)
    {
        while(j && p[i] != p[j + 1]) j = nxt[j];
        if (p[i] == p[j + 1]) j++;
        nxt[i] = j;
    }


    // 预生成nxt
    for (int i = 1, j = 0; i <= m; i++)
    {
        while(j && s[i] != p[j + 1]) j = nxt[j];
        if (s[i] == p[j + 1]) j++;
        if (j == n)
        {
            printf("%d ", i - n);
            j = nxt[j]; // 都匹配完了，下一次子串要怎么跳呢，这样跳最优。
        }
    }
    
    printf("\n");
    return 0;
}
```

